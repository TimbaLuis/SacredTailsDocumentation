<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Sistema de batallas | Example Unity documentation </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="Sistema de batallas | Example Unity documentation ">
    <meta name="generator" content="docfx 2.59.4.0">
    
    <link rel="shortcut icon" href="../favicon.ico">
    <link rel="stylesheet" href="../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../styles/docfx.css">
    <link rel="stylesheet" href="../styles/main.css">
    <meta property="docfx:navrel" content="../toc.html">
    <meta property="docfx:tocrel" content="toc.html">
    
    <meta property="docfx:rel" content="../">
    
  </head>
  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="../index.html">
                <img id="logo" class="svg" src="../logo.svg" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div class="container body-content">
        
        <div id="search-results">
          <div class="search-list">Search Results for <span></span></div>
          <div class="sr-items">
            <p><i class="glyphicon glyphicon-refresh index-loading"></i></p>
          </div>
          <ul id="pagination" data-first="First" data-prev="Previous" data-next="Next" data-last="Last"></ul>
        </div>
      </div>
      <div role="main" class="container body-content hide-when-search">
        
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="">
<h1 id="sistema-de-batallas">Sistema de batallas</h1>

<p>El sistema se compone basicamente de 3 controladores pilares: </p>
<ul>
<li>El <strong>GameSceneManager.cs</strong>: El cual recibe la peticion de crear un match y configura los datos iniciales necesario para empezar la batalla.</li>
<li>El <strong>BattleGameMode.cs</strong>: El cual maneja informacion general de la partida como la informacion de los jugadores y tambien el cual maneja el estado del juego como el inicio y final de la partida.</li>
<li>El <strong>TurnsController.cs</strong>: El controlador principal de la partida. En este se maneja la logica de los turnos individuales y del flujo de estos. </li>
</ul>
<p>Vamos a ver cada uno de ellos en mas detalle. </p>
<h1 id="gamescenemanagercs">GameSceneManager.cs</h1>
<p>A esta clase se le hace la peticion de crear una batalla nueva con el metodo <a href="//TODO">SendBattle</a>. Es necesario pasarle los datos necesario como el matchId de la partida y los perros actuales de los jugadores y sus stats. Luego de esto, se crea una instancia de la batalla, se cambia el estado del jugador en la base de datos a combate y apaga las ventanas abiertas al momento. Luego de eso pasa el flujo al battle gamemode con todos los datos necesarios para iniciar la batalla.</p>
<p>Por otra parte, al acabar la batalla, este es el controlador que nos devuelve al lobby, volviendo a mostrar la UI de lobby y borrando la instancia de combate.</p>
<h1 id="battlegamemodecstodo"><a href="//TODO">BattleGameMode.cs</a></h1>
<p>En el battle game mode tenemos el flujo <strong>pre-batalla</strong> y el de mostrar <strong>final de batalla</strong>. Tambien manejamos aqui los <strong>datos generales</strong> de los usuarios en la batalla.</p>
<p>Empezamos en el metodo <a href="//TODO">OnStartMatchRoutine</a>, una vez ya inicializados los datos, con la inicializacion del selector de shinseis pre-batalla. Estos son manejados por controladores como el <a href="//TODO">ArenaShinseiSelectionController.cs</a> y el <a href="//TODO">ArenaShinseiSelectionUserPanelController</a> los cuales manejan todo el flujo de ver y escoger los perros para la batalla. </p>
<p>Una vez escogidos se le <strong>notifica al BattleGameMode.cs</strong> con los perros que se escogieron o con el hecho de que se acabo el tiempo y no se escogieron perros. Si efectivamente se escogieron, procede a mandar los <strong>indices</strong> de los perros escogidos a el servidor por medio de un <strong>CloudScript</strong>.</p>
<p> Luego el flujo pasa a esperar a que el otro jugador escoja y una vez echo esto se <strong>inicializan  los datos de los perros escogidos, las barras de vida y energia, el sistema de cambio de shinsei y se spawnean los shinseis</strong>. </p>
<p> Despues de esto sigue con las camaras de inicio, las cuales muestran a los perros de frente y finalmente una vez esas camaras terminan de mostrar los perros, se inicializa la UI. Apartir de aqui, el <a href="//TODO">TurnsController.cs</a> controlara el resto del flujo de la batalla.</p>
<p>Una vez terminado el match se regresara al <a href="//TODO">BattleGameMode.cs</a> para mostrar la pantalla de resultados con el metodo <a href="//TODO">ShowEndResultPanel</a></p>
<h1 id="turnscontrollercstodo"><a href="//TODO">TurnsController.cs</a></h1>
<p>Esta clase maneja el flujo de la batalla una vez ha empezado. Se inicializa junto con el <a href="">BattleGameMode.cs</a> e inicializa las dependencias de los <a href="#battle-actions">Battle Actions</a>. Luego continuamos el flujo con cada inicio de turno. Cada vez que empieza un turno se verifica si el jugador esta durmiendo o no para poder ejectuar la animacion y enviar un salto de turno obligatorio y asi simular el estado dormido. Esta es una solucion temporal que se debe cambiar por un BattleAction, sin embargo de momento esta asi.</p>
<blockquote><h2 id="envio-de-turno">Envio de Turno</h2>
<p>Luego el flujo continua cuando el jugador decide mandar una accion con el metodo <a href="">SendTurnRequest</a>, bien sea una de sus cartas, un cambio de shinsei, un skip turn o un surrender. Todas estas acciones se mandan con un indice de la siguiente forma:</p>
<ul>
<li>0,1,2,3 =&gt; Ataques del shinsei en ese respectivo orden</li>
<li>4,5,6 =&gt; Cambio al shinsei respectivo (i.e: 4 -&gt; primer shinsei)</li>
<li>7 =&gt; Skip Turn</li>
<li>8 =&gt; Surrender</li>
</ul>
</blockquote>
<p>El indice se manda al servidor por medio de un <strong>CloudScript</strong>. Si la <strong>peticion falla</strong> se <strong>vuelve a internar mandar el turno</strong> hasta un maximo de 7 veces. Despues de eso <strong>se considera una desconexion del jugador</strong> que no pudo enviar el turno. Tambien se tiene en cuenta el caso en el que por cualquier razon el match ya termino segun el servidor. En este caso se llama al <a href="">BattleGameMode.cs</a> para terminar el match en el cliente.</p>
<p>En el caso de que todo funcione correctamente, seguimos a esperar el turno del otro jugador.</p>
<blockquote><h2 id="recibir-turnos-de-los-dos-jugadores">Recibir turnos de los dos jugadores</h2>
</blockquote>
<p>El metodo <a href="">WaitOponentTurn()</a> nos ayuda a esperar el turno del contrincante al mandar un <strong>CloudScript</strong>  cada X segundos, siendo X el tiempo definido por parametro (i.e: 3segundos). Esta peticion realiza todos los calculos necesarios en el <strong>servidor</strong> para que este procese y tengo un <strong>snapshot de la partida</strong> con esos turnos procesados. Luego una vez finalizado ese proceso nos devuelve los turnos de los dos jugadores para que el <strong>cliente procese los turnos el mismo</strong>. Este metodo maneja y delega desde el <a href="#final-de-la-partida">final de la partida</a> hasta el procesamiento de estados alterados, terrenos y BattleActions.</p>
<p>En cuanto a los <strong>Terrenos</strong>, estos son guardados en el <a href="">BattleGameMode.cs</a> y solo puede existir <strong>uno a la vez</strong>. Cada  terreno tiene su controlador el cual hereda de la base <a href="">BattleTerrainBehavioursBase</a>. </p>
<p>Pasa algo similar con los <strong>estados alterados</strong>, solo que estos en vez de guardarse en el <a href="">BattleGameMode.cs</a> per se, se guardan en los shinseis especificos que tienen los estados alterados. Pero estos si pueden ser multiples por shinsei. Todos son controlados por clases que heredan de <a href="">BattleAlteredStateBase</a>.</p>
<p>El <strong>procesamiento de los estado alterado y las battleActions</strong> del jugador actual se encapsula en un evento o Action que se le es pasado al metodo <a href="">InitTurnFlow()</a>. Este metodo con ayuda de la respuesta del servidor, determina quien inicia el turno primero y si el otro jugador puede ejecutar el turno o si no puede dado a que murio o esta dormido. Este metodo maneja los tiempos basados en un action time que se define al inicio de la ejecucion de los estados alterados y de las <a href="#battle-actions">Battle Actions</a>. Despues de definir el tiempo para que el <a href="">InitTurnFlow()</a> espere, estas se ejecutan con sus vfx y camaras.</p>
<blockquote><h2 id="battle-actionstodo"><a href="//TODO">Battle Actions</a></h2>
<p>Las battle actions son ejecutadas con ayuda del metodo <a href="">CalculateIncomingActions()</a>. Este metodo aplica la energia y ejecuta las Battle Actions en el orden en el que el jugador las ha recibido/enviado. Estas battle actions varian desde un ataque, un heal, un buffdebuff, poner estados alterados o terrenos, etc. Cada una de estas acciones tiene un controlador que hereda de <a href="">BattleActionsBase</a>. Esta base ejecuta el vfx con sus tiempos para que sus herencias solo se preocupen por la logica de la accion. Como habiamos dicho antes el tiempo de vfx se envia antes al turns controller para que el metodo [InitTurnFlow()] pueda controlar los tiempos de espera a que las habilidades terminado de ejecutar sus vfx. Al terminar de ejecutar el metodo con todas las acciones, se procede a revisar si los perros han muerto y si ya murieron todos para acabar la partida localmente.</p>
<h2 id="final-de-la-partida">Final de la partida</h2>
</blockquote>
<p>El final de la partida se ejecuta si el servidor lo indica, bien sea por la deteccion de un surrender o por que el match termino en el server. Tambien se ejecuta si el cliente termina la partida con sus valores actuales, esta es una medida de seguridad, sin embargo todos los premios, puntajes, etc se veran reflejados en como termine la partida en el servidor.</p>
</article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                  <li>
                    <a href="https://github.com/ifalvarez/SacredTails/blob/Dev/Documentation/manual/etiam.md/#L1" class="contribution-link">Improve this Doc</a>
                  </li>
                </ul>
              </div>
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
                <h5>In This Article</h5>
                <div></div>
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            Example Unity documentation
            
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../styles/docfx.js"></script>
    <script type="text/javascript" src="../styles/main.js"></script>
  </body>
</html>
